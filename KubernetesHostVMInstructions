== VMWare Workstation virtual machine configuration ===================================================================

# Create VM
## Ubuntu (from disc image)
## Full name: CServer
## User name: c
## Password: b(short)
## Virtual machine name: UbuntuServer
## Location: C:\Virtual Machines\UbuntuServer
## Maximum disk size: 35GB
## CHECK Store virtual disk as single file
## Customize Hardware:
### Memory: 6144MB
### Processors: 1, 6 cores per processor
### Network Adapter: Check 'Bridged: Connected directly to the physical network'

== Initial Setup ======================================================================================================

# Skip 'Online Accounts'
## 'Next' top-right through all 

# [QOL] Open terminal (Action key, Terminal), then remove all favorites except terminal and file explorer.

# [QOL] Longer screen lock delay
Win/Action key -> Activities -> Privacy (left pane) -> Screen Lock (left pane) -> Set 'Blank Screen Delay' to 15 minutes

== Repository =========================================================================================================

# Install Git
sudo apt install git

# Git credentials
git config --global credential.helper store

# Clone LifeManager
git clone https://github.com/ConorJS/LifeManager.git ~/LifeManager/Repository

== Configure terminal =================================================================================================

# Update .bashrc
gio open ~/.bashrc
At bottom, paste the contents of the following file:
	gio open ~/LifeManager/Repository/.bashrc_Linux.sh
	
# Update package manager
sudo apt-get update

# [QOL] Configure terminal preferences
gsettings get org.gnome.Terminal.ProfilesList default
GNOME_TERMINAL_PROFILE=`gsettings get org.gnome.Terminal.ProfilesList default | awk -F \' '{print $2}'`
gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ use-system-font false
gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ font 'Monospace 9'
gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ default-size-rows 36
gsettings set org.gnome.Terminal.Legacy.Profile:/org/gnome/terminal/legacy/profiles:/:$GNOME_TERMINAL_PROFILE/ default-size-columns 120

# [QOL] High ~/.bash_history limit:
HISTFILESIZE=1000

== Basic programs =====================================================================================================

# [QOL] Download/install/favorite Chrome
wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
sudo apt install ./google-chrome-stable_current_amd64.deb
# Opens Chrome; mark as Favorite, also grab: https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm?hl=en)
google-chrome

# [QOL] Download/install Notepadqq
sudo apt install notepadqq
# Favorite when open
notepadqq 

# [QOL] Set Notepadqq as default text editor
touch a
gio open .
Right click 'a' in the file explorer > Properties > Open With > Notepadqq > Set as default

== Docker installation (necessary for Kubernetes) =====================================================================

# Allow apt to use a repository over HTTPS
sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
	
# Add Dockerâ€™s official GPG key
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

# Verify the GPG key:
sudo apt-key fingerprint 0EBFCD88

# Set up the Docker 'stable' repository:
sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
   $(lsb_release -cs) \
   stable"
   
# Install the Docker engine
sudo apt-get install docker-ce docker-ce-cli containerd.io

# Add and populate Docker group (Should be unnecessary, installing Docker should do this)
sudo groupadd docker

# aG = append to group, without removing user from other groups
# Restart the VM after this, to apply the setting, and test the Docker engine with the next step to verify.
sudo usermod -aG docker ${USER}

# [OPTIONAL] Test the Docker engine
docker run hello-world

# [OPTIONAL] Test LifeManager docker instance [NOTE: If this works, remove 'sudo' from Docker.sh]
cd ~/LifeManager/Repository
sudo chmod 555 Docker.sh
./Docker.sh

== Kubernetes (installation - once only per VM) =======================================================================
# More info (Minikube): https://minikube.sigs.k8s.io/docs/start/

# Install kubectl
sudo apt install curl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

# [OPTIONAL] Validate kubectl
kubectl version --client

# Install Minikube
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# Gets the Minikube server IP instance, and adds ''<ip>	lifemanager.info' to hosts file.
minikube start
sudo -- sh -c "printf '\n%s\tlifemanager.info' $(minikube ip) >> /etc/hosts"
minikube stop

============= Kubernetes (Application deployment) =====================================================================

# Start Minikube
minikube start

## Pushing to a minikube cluster (see: https://minikube.sigs.k8s.io/docs/handbook/pushing/)
# Switch the current terminal from targeting the default Docker driver (if present) to that of minikube's
# This means all Docker images built/deployed in this terminal will be a part of the local Kubernetes 
# cluster managed by minikube
eval $(minikube docker-env)

## Creating an appropriately tagged LifeManager Docker image
lm
COMMIT=$(git rev-parse --verify HEAD)
docker image build . -t "lifemanager-image:latest" -t "lifemanager-image:${COMMIT}"

# Applying the LifeManager cluster objects
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
kubectl apply -f ingress.yaml

# Enabling the minikube ingress controller
minikube addons enable ingress

============= Kubernetes (Application re-deployment) ==================================================================

# Redeploying the LifeManager application
docker image prune -f
docker image prune -fa
lm
kubectl delete -f deployment.yaml
COMMIT=$(git rev-parse --verify HEAD)
docker image build . -t "lifemanager-image:latest" -t "lifemanager-image:${COMMIT}"
kubectl create -f deployment.yaml

== Kubernetes (Post-installation testing - optional) ==================================================================

# [OPTIONAL] Check the Minikube pod is running
kubectl get po -A

# [OPTIONAL] Run the Minikube dashboard
minikube dashboard

============= Kubernetes (PostgreSQL database) ========================================================================

# Create the Docker image for the Postgres deployment (must be within minikube's Docker service)
lm
cd LifeManager/Environment/Database
COMMIT=$(git rev-parse --verify HEAD)
docker image build . -t "lifemanager-db-image:latest" -t "lifemanager-db-image:${COMMIT}"

# Configure the PostgreSQL config map, deployment, persistent volume, persistent volume claim and service in Kubernetes.
kubectl create -f postgres-configmap.yaml 
kubectl create -f postgres-storage.yaml 
kubectl create -f postgres-deployment.yaml 
kubectl create -f postgres-service.yaml

# Back up the Postgres database
bkdir=~/Desktop/backup456
lm
cd LifeManager/Environment/Database
kubectl delete -f postgres-deployment.yaml 
kubectl delete -f postgres-service.yaml 
kubectl delete -f postgres-storage.yaml 
minikube stop
sudo cp -r /var/lib/docker/volumes/minikube/_data/data/psql $bkdir
minikube start
kubectl create -f postgres-storage.yaml 
kubectl create -f postgres-deployment.yaml 
kubectl create -f postgres-service.yaml

# Restore the Postgres database from a backup (OVERWRITES EXISTING DATABASE!)
bkdir=~/Desktop/backup456
lm
cd LifeManager/Environment/Database
kubectl delete -f postgres-deployment.yaml 
kubectl delete -f postgres-service.yaml 
kubectl delete -f postgres-storage.yaml 
minikube stop
sudo rm -rf /var/lib/docker/volumes/minikube/_data/data/psql
sudo cp -r $bkdir /var/lib/docker/volumes/minikube/_data/data/psql
minikube start
kubectl create -f postgres-storage.yaml 
kubectl create -f postgres-deployment.yaml 
kubectl create -f postgres-service.yaml

# Remove the Postgres database
lm
cd LifeManager/Environment/Database
kubectl delete -f postgres-deployment.yaml 
kubectl delete -f postgres-service.yaml 
kubectl delete -f postgres-storage.yaml 
minikube stop
sudo rm -rf /var/lib/docker/volumes/minikube/_data/data/psql
docker image prune -f
docker image prune -fa
minikube start

#[USEFUL] Remove the Postgres Kubernetes objects in an order that works
kubectl delete -f postgres-deployment.yaml 
kubectl delete -f postgres-service.yaml 
kubectl delete -f postgres-storage.yaml 

#[TESTING] Find the Postgres service port, then connect to Postgres service from the LifeManager pod
kubectl get svc lifemanager-postgres-service
kubectl get pod | grep lifemanager-deployment | awk '{print $1}'
psql -h localhost -U lmadmin --password -p <port> postgres-persistent-storage

============= Kubernetes (Flyway)======================================================================================

# Running Flyway migration job
lm
cd LifeManager/Environment/Database/Flyway/
docker image build . -t "lifemanager-flyway-image:latest" -t "lifemanager-flyway-image:${COMMIT}"
kubectl apply -f flyway-migration-job.yaml

============= Kubernetes (helpful/to be integrated) ===================================================================

# See if the active terminal is running with minikube's Docker driver
echo $MINIKUBE_ACTIVE_DOCKERD

# SSH into minikube (Can be used to view persistence volumes directly)
minikube ssh

# Show current logs for a pod
kubectl logs <lifemanager pod name>

# Caching images in minikube (e.g. Alpine, as follows)
minikube cache add alpine:latest

# Restart the LifeManager Kubernetes deployment
kubectl rollout restart deployment lifemanager-deployment

# Get a shell running in the pod
kubectl exec --stdin --tty <lifemanager pod name> -- /bin/bash

# Diagnostics
kubectl get [deploy|svc|pod]

# Delete all LifeManager deployments|services|pods
kubectl get [deploy|svc|pod] awk '/lifemanager/{print $1}' | xargs kubectl delete [deploy|svc|pod] 

============= Optional ================================================================================================

# Install net-tools (ifconfig)
sudo apt install net-tools

# Install apt-file (allows search for packages in apt e.g. apt-file search somepackage)
sudo apt install apt-file

# Install ping
apt-get update 
apt-get install iputils-ping

============= Generally helpful =======================================================================================

# Search apt index
apt-cache search <keyword>

# Recursively show files in filesystem, with full paths and file sizes
du -a

============= Doesn't work (yet) ======================================================================================

## Fix mouse scroll
# Install xserver-xorg-input-evdev (fixes issue where you can't scroll while moving mouse in a Linux VM)
sudo apt-get install xserver-xorg-input-evdev

# Configure Ubuntu to use the evdev driver:
o /usr/share/X11/xorg.conf.d/40-libinput.conf
# Then, in the section like (note there are many similar sections, refer to the one with 'pointer' on line 2):
# Section "InputClass"
#        Identifier "libinput pointer catchall"
#        MatchIsPointer "on"
#        MatchDevicePath "/dev/input/event*"
#        Driver "libinput"
# Change 'Driver "libinput"' to 'Driver "evdev"'


=======================================================================================================================
============= OLD =====================================================================================================
=======================================================================================================================


============= Docker (PostgreSQL database) ============================================================================

## Creating an appropriately tagged LifeManager PostgreSQL Docker image (duplicated in Kubernetes Postgres section)
lm
cd LifeManager/Environment/Database
COMMIT=$(git rev-parse --verify HEAD)
docker image build . -t "lifemanager-db-image:latest" -t "lifemanager-db-image:${COMMIT}"

# Runs the plain 'postgres' image as a Docker PostgreSQL database instance called 'lifemanager-db', on port 5432.
docker run -d --name lifemanager-db -e POSTGRES_PASSWORD=lfemgr -v ~/pg-data-test:/var/lib/postgresql/data -p 5432:5432 postgres

# Runs the 'lifemanager-db-image' as a Docker PostgreSQL database instance called 'lifemanager-db', on port 5432.
docker run -d --name lifemanager-db-image \
	-e POSTGRES_PASSWORD=lfemgr \
	-v ~/pg-data-test:/var/lib/postgresql/data \
	-p 5432:5432 \
	lifemanager-db-image
	
# Run a pgAdmin 4 instance (TODO: Get this into Kubernetes cluster)
docker run -p 80:80 -e 'PGADMIN_DEFAULT_EMAIL=user@domain.local' -e 'PGADMIN_DEFAULT_PASSWORD=SuperSecret' --name lifemanager-pgadmin -d dpage/pgadmin4

# [USEFUL] Show logs for LifeManager database instance (Docker only)
docker container list -a | awk '/lifemanager-db-image/{print $1}' | xargs docker container logs

# [USEFUL] Kill/delete/show logs for any/all Docker container which run from LifeManager database images (Docker only)
sudo rm ~/pg-data-test -R
docker container list -a | awk '/lifemanager-db-image/{print $1}' | xargs docker container kill
docker container list -a | awk '/lifemanager-db-image/{print $1}' | xargs docker container rm
docker container list -a | grep Exited | awk '/ago/{print $1}' | xargs docker container rm 
docker image list -a | awk '/lifemanager-db-image/{print $3}' | xargs docker rmi
COMMIT=$(git rev-parse --verify HEAD)
docker image build . -t "lifemanager-db-image:latest" -t "lifemanager-db-image:${COMMIT}"
docker run -d --name lifemanager-db-image \
	-e POSTGRES_PASSWORD=lfemgr \
	-v ~/pg-data-test:/var/lib/postgresql/data \
	-p 5432:5432 \
	lifemanager-db-image
# (Wait a few seconds for database to be ready before executing these)
docker exec -it $(docker ps | grep lifemanager-db-image | awk '{print  $1 " bash"}' )
psql -h localhost -U lmadmin -d lifemanager
\l

============= Docker (Flyway) =========================================================================================

# Runs the Flyway docker instance, providing the LifeManager Flyway configuration and migration script paths.
lm
docker run --rm \
	-v $(pwd)/LifeManager/Environment/Database/Flyway:/flyway/sql \
	-v $(pwd)/LifeManager/Environment/Database/../:/flyway/conf \
	flyway/flyway \
	-url=jdbc:postgresql://172.17.0.2:5432/lifemanager \
	-user=lmadmin -password=lfemgr \
	-defaultSchema=public -schemas=lifemanager,public \
	-validateMigrationNaming=true \
	migrate

== Docker (helpful) ===================================================================================================

# Bash shell in a Docker instance
docker exec -it <container id> /bin/bash
docker exec -it $(docker ps | grep lifemanager-db-image | awk '{print  $1 " bash"}' )

# Remove all dangling Docker images
docker rmi $(docker images --filter "dangling=true" -q --no-trunc)

# Show information about a Docker instance
docker inspect lifemanager-db

# Show IP address of Docker instance
docker inspect lifemanager-db | grep \"IPAddress\":

# Remove/Kill all Docker containers/images like a certain name
docker image list -a | awk '/<name section e.g. lifemanager-db>/{print $3}' | xargs docker rmi
docker container list -a | awk '/<name section e.g. lifemanager-db>/{print $1}' | xargs docker container kill
docker container list -a | awk '/<name section e.g. lifemanager-db>/{print $1}' | xargs docker container rm

# Remove all stopped Docker containers in a (mostly) safe mannner, will also hit containers with 'Exited' and 'ago' in the image/container name.
docker container list -a | grep Exited | awk '/ago/{print $1}' | xargs docker container rm 

== Kubernetes (old) ===================================================================================================

# Create/expose test deployment
kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4
kubectl expose deployment hello-minikube --type=NodePort --port=8080

# Delete the test deployment
kubectl delete service hello-node
kubectl delete deployment hello-node

# View services (TODO - This is a Hello World app currently)
kubectl get services hello-minikube

# Show all Docker images:
docker images --all

# Proxy the ports on VM that minikube runs Kubernetes to interact with the the host (localhost)
# NOTE: Do this in another terminal, as this is a blocking process!
minikube tunnel

# Running the built LifeManager image
docker run -p 5050:80 lifemanager

# Running the LifeManager image directly in Kubernetes
kubectl run lifemanager --image=lifemanager --image-pull-policy=Never

# Get LifeManager pod name, and port forward to it so it is visible on the host
kubectl port-forward <lifemanger pod name> 5051:80

# Port forward the LifeManager Kubernetes service so that it is visible on the host (bypassing ingress)
kubectl port-forward svc/lifemanager-service 5051:5052